import { formatCurrency, sanitize } from './number';

const INCOME_TYPES = new Set(["income", "rent", "rental", "other_income"]);
const EXPENSE_TYPES = new Set(["expense", "maintenance", "repair", "fees", "insurance", "tax", "management_fee", "interest"]);
const IGNORE_IN_PNL = new Set(["principal"]);

const sanitizeNumberInput = (value) => {
  if (value === null || value === undefined || value === '') return 0;
  const num = typeof value === 'string' ? parseFloat(value) : Number(value);
  return isNaN(num) ? 0 : num;
};

const filterTransactionsByDateRange = (transactions, startDate, endDate) => {
  return transactions.filter(transaction => {
    if (!transaction.date) return false;
    const transactionDate = new Date(transaction.date);
    return transactionDate >= startDate && transactionDate <= endDate;
  });
};

const getYearRange = (year) => {
  return {
    start: new Date(year, 0, 1),
    end: new Date(year, 11, 31, 23, 59, 59)
  };
};

// Enhanced daily conversion function with precise calculations
export const calculateDailyAmount = (amount, frequency) => {
  const numAmount = sanitize(amount);
  
  switch (frequency?.toLowerCase()) {
    case 'daily':
      return numAmount;
    case 'weekly':
      return numAmount / 7;
    case 'fortnightly':
    case 'biweekly':
      return numAmount / 14;
    case 'monthly':
      // Use precise monthly to daily conversion (365.25 / 12)
      return numAmount / 30.4375;
    case 'quarterly':
      // Use precise quarterly to daily conversion (365.25 / 4)
      return numAmount / 91.3125;
    case 'semi-annually':
      // Use precise semi-annual to daily conversion (365.25 / 2)
      return numAmount / 182.625;
    case 'annually':
    case 'yearly':
      // Account for leap years
      return numAmount / 365.25;
    default:
      return numAmount / 7; // Default to weekly
  }
};

// Generate rental transactions with precise daily conversion
export const generateRentalTransactions = (property, startDate, endDate) => {
  const transactions = [];
  
  if (!property || !startDate || !endDate) return transactions;
  
  const start = new Date(startDate);
  const end = new Date(endDate);
  
  // Process property-level rental if exists
  if (property.rental && property.rental.amount) {
    const rental = property.rental;
    const dailyAmount = calculateDailyAmount(rental.amount, rental.frequency || 'monthly');
    const managementFeeRate = sanitize(rental.managementFeeRate || rental.feeRate || 0) / 100;
    const dailyFee = dailyAmount * managementFeeRate;
    
    // Generate daily transactions for the date range
    for (let currentDate = new Date(start); currentDate <= end; currentDate.setDate(currentDate.getDate() + 1)) {
      const dateStr = currentDate.toISOString().split('T')[0];
      
      // Rental income transaction
      if (dailyAmount > 0) {
        transactions.push({
          id: `rental_daily_${property.id}_${dateStr}`,
          propertyId: property.id,
          type: 'income',
          category: 'Rental Income',
          description: `Daily Rent (${rental.frequency || 'monthly'}) - ${property.address || property.name || 'Property'}`,
          amount: dailyAmount,
          date: dateStr,
          isAutoGenerated: true,
          originalAmount: rental.amount,
          originalFrequency: rental.frequency || 'monthly'
        });
      }
      
      // Management fee transaction
      if (dailyFee > 0) {
        transactions.push({
          id: `mgmt_fee_daily_${property.id}_${dateStr}`,
          propertyId: property.id,
          type: 'management_fee',
          category: 'Management Fees',
          description: `Daily Management Fee (${(managementFeeRate * 100).toFixed(1)}%)`,
          amount: dailyFee,
          date: dateStr,
          isAutoGenerated: true,
          originalAmount: rental.amount * managementFeeRate,
          originalFrequency: rental.frequency || 'monthly'
        });
      }
    }
  }
  
  // Process rentals array if exists
  if (Array.isArray(property.rentals)) {
    property.rentals.forEach((rental, index) => {
      if (!rental || !rental.amount) return;
      
      const dailyAmount = calculateDailyAmount(rental.amount, rental.frequency || 'monthly');
      const managementFeeRate = sanitize(rental.managementFeeRate || rental.feeRate || 0) / 100;
      const dailyFee = dailyAmount * managementFeeRate;
      const unitName = rental.unitName || rental.name || `Unit ${index + 1}`;
      
      for (let currentDate = new Date(start); currentDate <= end; currentDate.setDate(currentDate.getDate() + 1)) {
        const dateStr = currentDate.toISOString().split('T')[0];
        
        // Rental income transaction
        if (dailyAmount > 0) {
          transactions.push({
            id: `rental_daily_${property.id}_${index}_${dateStr}`,
            propertyId: property.id,
            type: 'income',
            category: 'Rental Income',
            description: `Daily Rent (${rental.frequency || 'monthly'}) - ${unitName}`,
            amount: dailyAmount,
            date: dateStr,
            isAutoGenerated: true,
            originalAmount: rental.amount,
            originalFrequency: rental.frequency || 'monthly',
            unitName: unitName
          });
        }
        
        // Management fee transaction
        if (dailyFee > 0) {
          transactions.push({
            id: `mgmt_fee_daily_${property.id}_${index}_${dateStr}`,
            propertyId: property.id,
            type: 'management_fee',
            category: 'Management Fees',
            description: `Daily Management Fee (${(managementFeeRate * 100).toFixed(1)}%) - ${unitName}`,
            amount: dailyFee,
            date: dateStr,
            isAutoGenerated: true,
            originalAmount: rental.amount * managementFeeRate,
            originalFrequency: rental.frequency || 'monthly',
            unitName: unitName
          });
        }
      }
    });
  }
  
  // Process units array if exists
  if (Array.isArray(property.units)) {
    property.units.forEach((unit, unitIndex) => {
      if (!unit || !unit.rental || !unit.rental.amount) return;
      
      const rental = unit.rental;
      const dailyAmount = calculateDailyAmount(rental.amount, rental.frequency || 'monthly');
      const managementFeeRate = sanitize(rental.managementFeeRate || rental.feeRate || 0) / 100;
      const dailyFee = dailyAmount * managementFeeRate;
      const unitName = unit.name || `Unit ${unitIndex + 1}`;
      
      for (let currentDate = new Date(start); currentDate <= end; currentDate.setDate(currentDate.getDate() + 1)) {
        const dateStr = currentDate.toISOString().split('T')[0];
        
        // Rental income transaction
        if (dailyAmount > 0) {
          transactions.push({
            id: `unit_rental_daily_${property.id}_${unitIndex}_${dateStr}`,
            propertyId: property.id,
            type: 'income',
            category: 'Rental Income',
            description: `Daily Rent (${rental.frequency || 'monthly'}) - ${unitName}`,
            amount: dailyAmount,
            date: dateStr,
            isAutoGenerated: true,
            originalAmount: rental.amount,
            originalFrequency: rental.frequency || 'monthly',
            unitName: unitName
          });
        }
        
        // Management fee transaction
        if (dailyFee > 0) {
          transactions.push({
            id: `unit_mgmt_fee_daily_${property.id}_${unitIndex}_${dateStr}`,
            propertyId: property.id,
            type: 'management_fee',
            category: 'Management Fees',
            description: `Daily Management Fee (${(managementFeeRate * 100).toFixed(1)}%) - ${unitName}`,
            amount: dailyFee,
            date: dateStr,
            isAutoGenerated: true,
            originalAmount: rental.amount * managementFeeRate,
            originalFrequency: rental.frequency || 'monthly',
            unitName: unitName
          });
        }
      }
    });
  }
  
  return transactions;
};

// Generate loan payment transactions with daily conversion
export const generateLoanPayments = (loans, properties, startDate, endDate) => {
  const transactions = [];
  
  if (!Array.isArray(loans) || !startDate || !endDate) return transactions;
  
  const start = new Date(startDate);
  const end = new Date(endDate);
  
  loans.forEach(loan => {
    if (!loan || loan.status !== 'active' || !loan.monthlyPayment) return;
    
    const property = properties?.find(p => p?.id === loan.propertyId);
    if (!property) return;
    
    // Convert monthly loan payment to daily
    const dailyPayment = calculateDailyAmount(loan.monthlyPayment, 'monthly');
    const interestRate = sanitize(loan.interestRate || 0) / 100 / 365.25; // Daily interest rate
    const currentBalance = sanitize(loan.currentBalance || loan.originalAmount || 0);
    
    // Calculate daily interest and principal portions
    const dailyInterest = currentBalance * interestRate;
    const dailyPrincipal = Math.max(0, dailyPayment - dailyInterest);
    
    for (let currentDate = new Date(start); currentDate <= end; currentDate.setDate(currentDate.getDate() + 1)) {
      const dateStr = currentDate.toISOString().split('T')[0];
      
      // Daily interest payment
      if (dailyInterest > 0) {
        transactions.push({
          id: `loan_interest_daily_${loan.id}_${dateStr}`,
          propertyId: loan.propertyId,
          type: 'interest',
          category: 'Loan Interest',
          description: `Daily Loan Interest - ${loan.lender || 'Lender'}`,
          amount: dailyInterest,
          date: dateStr,
          isAutoGenerated: true,
          originalAmount: loan.monthlyPayment,
          originalFrequency: 'monthly',
          loanId: loan.id
        });
      }
      
      // Daily principal payment
      if (dailyPrincipal > 0) {
        transactions.push({
          id: `loan_principal_daily_${loan.id}_${dateStr}`,
          propertyId: loan.propertyId,
          type: 'principal',
          category: 'Loan Principal',
          description: `Daily Loan Principal - ${loan.lender || 'Lender'}`,
          amount: dailyPrincipal,
          date: dateStr,
          isAutoGenerated: true,
          originalAmount: loan.monthlyPayment,
          originalFrequency: 'monthly',
          loanId: loan.id
        });
      }
    }
  });
  
  return transactions;
};

export const computePurchasePrice = (property) => {
  if (!property) return 0;
  return sanitize(property.currentValue || property.purchasePrice || 0);
};

export const calculatePropertyMetrics = (property, transactions, rentals, expenses, loans, year = new Date().getFullYear()) => {
  if (!property) return getDefaultMetrics();

  const { start: yearStart, end: yearEnd } = getYearRange(year);
  
  // Filter transactions for this property and year
  const yearTransactions = filterTransactionsByDateRange(
    transactions.filter(t => t.propertyId === property.id),
    yearStart,
    yearEnd
  );

  // Calculate income and expenses using unified type sets
  const income = yearTransactions
    .filter(t => t && !IGNORE_IN_PNL.has(String(t.type || "").toLowerCase()))
    .filter(t => {
      const ttype = String(t.type || "").toLowerCase();
      const amt = sanitize(t.amount);
      return INCOME_TYPES.has(ttype) || (!ttype && amt > 0);
    })
    .reduce((sum, t) => sum + sanitize(t.amount), 0);

  const totalExpenses = yearTransactions
    .filter(t => t && !IGNORE_IN_PNL.has(String(t.type || "").toLowerCase()))
    .filter(t => {
      const ttype = String(t.type || "").toLowerCase();
      const amt = sanitize(t.amount);
      return EXPENSE_TYPES.has(ttype) || (!ttype && amt < 0);
    })
    .reduce((sum, t) => sum + Math.abs(sanitize(t.amount)), 0);

  const netCashFlow = income - totalExpenses;

  // Property loan information
  const propertyLoans = loans.filter(loan => loan.propertyId === property.id && loan.status === 'active');
  const totalLoanAmount = propertyLoans.reduce((sum, loan) => sum + sanitize(loan.currentBalance || loan.originalAmount), 0);
  const totalMonthlyLoanPayment = propertyLoans.reduce((sum, loan) => sum + sanitize(loan.monthlyPayment), 0);

  // Calculate property value and equity
  const propertyValue = sanitize(property.currentValue || property.purchasePrice);
  const equity = Math.max(0, propertyValue - totalLoanAmount);
  const equityPercentage = propertyValue > 0 ? (equity / propertyValue) * 100 : 0;

  // Calculate cash-on-cash return
  const cashInvested = sanitize(property.downPayment) + sanitize(property.closingCosts) + sanitize(property.renovationCosts);
  const cashOnCashReturn = cashInvested > 0 ? (netCashFlow / cashInvested) * 100 : 0;

  // Calculate cap rate
  const capRate = propertyValue > 0 ? (netCashFlow / propertyValue) * 100 : 0;

  return {
    income,
    expenses: totalExpenses,
    netCashFlow,
    totalLoanAmount,
    totalMonthlyLoanPayment,
    activeLoanCount: propertyLoans.length,
    propertyValue,
    equity,
    equityPercentage,
    cashOnCashReturn,
    capRate,
    cashInvested
  };
};

export const calculatePortfolioMetrics = (properties, loans, transactions, year = new Date().getFullYear(), settings = {}) => {
  if (!properties || properties.length === 0) return getDefaultPortfolioMetrics();

  let totalIncome = 0;
  let totalExpenses = 0;
  let totalValue = 0;
  let totalPurchasePrice = 0;
  let totalLoanAmount = 0;
  let totalMonthlyRepayment = 0;
  let activeLoanCount = 0;
  let propertiesWithLoans = 0;

  // Calculate metrics for each property and aggregate
  properties.forEach(property => {
    if (!property) return;
    
    const metrics = calculatePropertyMetrics(property, transactions, [], [], loans, year);
    
    totalIncome += metrics.income;
    totalExpenses += metrics.expenses;
    totalValue += sanitize(property.currentValue || property.purchasePrice || 0);
    
    // Calculate purchase price including acquisition costs
    const basePrice = sanitize(property.purchasePrice || 0);
    const acqCosts = Array.isArray(property.acquisitionCosts) ? 
      property.acquisitionCosts.reduce((sum, cost) => sum + sanitize(cost.amount || 0), 0) : 0;
    totalPurchasePrice += basePrice + acqCosts;
    
    totalLoanAmount += metrics.totalLoanAmount;
    totalMonthlyRepayment += metrics.totalMonthlyLoanPayment;
    activeLoanCount += metrics.activeLoanCount;
    if (metrics.activeLoanCount > 0) propertiesWithLoans++;
  });

  const netCashFlow = totalIncome - totalExpenses;
  const averageYield = totalValue > 0 ? (totalIncome / totalValue) * 100 : 0;

  return {
    totalIncome,
    totalExpenses,
    netCashFlow,
    totalValue,
    totalPurchasePrice,
    averageYield,
    propertyCount: properties.length,
    totalLoanAmount,
    totalMonthlyRepayment,
    activeLoanCount,
    propertiesWithLoans
  };
};

export const getPropertyLoanInfo = (propertyId, loans) => {
  const propertyLoans = loans.filter(loan => loan.propertyId === propertyId && loan.status === 'active');
  
  return {
    count: propertyLoans.length,
    totalAmount: propertyLoans.reduce((sum, loan) => sum + sanitize(loan.currentBalance || loan.originalAmount), 0),
    totalRepayment: propertyLoans.reduce((sum, loan) => sum + sanitize(loan.regularPaymentAmount || loan.monthlyRepayment), 0),
    loans: propertyLoans
  };
};

export const calculateActiveLoanMetrics = (loans) => {
  const activeLoans = loans.filter(loan => loan.status === 'active');
  
  const loansByProperty = {};
  let totalLoanAmount = 0;
  let totalMonthlyRepayment = 0;

  activeLoans.forEach(loan => {
    const propertyId = loan.propertyId;
    const loanAmount = sanitize(loan.currentBalance || loan.originalAmount);
    const monthlyPayment = sanitize(loan.regularPaymentAmount || loan.monthlyRepayment);

    if (!loansByProperty[propertyId]) {
      loansByProperty[propertyId] = {
        count: 0,
        totalAmount: 0,
        totalMonthly: 0,
        loans: []
      };
    }

    loansByProperty[propertyId].count++;
    loansByProperty[propertyId].totalAmount += loanAmount;
    loansByProperty[propertyId].totalMonthly += monthlyPayment;
    loansByProperty[propertyId].loans.push(loan);

    totalLoanAmount += loanAmount;
    totalMonthlyRepayment += monthlyPayment;
  });

  return {
    activeLoanCount: activeLoans.length,
    totalLoanAmount,
    totalMonthlyRepayment,
    loansByProperty
  };
};

export const getActiveRentals = (property) => {
  if (!property || !Array.isArray(property.rentals)) return [];
  
  const today = new Date();
  return property.rentals.filter(rental => {
    if (!rental || !rental.startDate) return false;
    
    const startDate = new Date(rental.startDate);
    const endDate = rental.endDate ? new Date(rental.endDate) : null;
    
    return startDate <= today && (!endDate || endDate >= today);
  });
};

export const getTotalActiveRentalIncome = (property) => {
  const activeRentals = getActiveRentals(property);
  
  return activeRentals.reduce((total, rental) => {
    const amount = sanitize(rental.amount);
    const frequency = rental.frequency || 'weekly';
    
    // Convert to annual amount
    switch (frequency.toLowerCase()) {
      case 'weekly':
        return total + (amount * 52);
      case 'fortnightly':
        return total + (amount * 26);
      case 'monthly':
        return total + (amount * 12);
      case 'quarterly':
        return total + (amount * 4);
      case 'annually':
        return total + amount;
      default:
        return total + (amount * 52); // Default to weekly
    }
  }, 0);
};

export const formatCurrencyWithFrequency = (amount, frequency) => {
  const formattedAmount = formatCurrency(amount);
  const freq = frequency ? frequency.toLowerCase() : 'weekly';
  
  const frequencyMap = {
    'daily': 'daily',
    'weekly': 'weekly',
    'fortnightly': 'fortnightly',
    'monthly': 'monthly',
    'quarterly': 'quarterly',
    'annually': 'annually'
  };
  
  return `${formattedAmount} ${frequencyMap[freq] || 'weekly'}`;
};

const getDefaultMetrics = () => ({
  income: 0,
  expenses: 0,
  netCashFlow: 0,
  totalLoanAmount: 0,
  totalMonthlyLoanPayment: 0,
  activeLoanCount: 0,
  propertyValue: 0,
  equity: 0,
  equityPercentage: 0,
  cashOnCashReturn: 0,
  capRate: 0,
  cashInvested: 0
});

const getDefaultPortfolioMetrics = () => ({
  totalIncome: 0,
  totalExpenses: 0,
  netCashFlow: 0,
  totalValue: 0,
  totalPurchasePrice: 0,
  averageYield: 0,
  propertyCount: 0,
  totalLoanAmount: 0,
  totalMonthlyRepayment: 0,
  activeLoanCount: 0,
  propertiesWithLoans: 0
});